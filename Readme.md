# Processor emulator

## Description

This bundle provides assembling, disassembling, executing and debugging code written in simplified intel assembler version. It consists of 3 modules, compiled at the same time into a different executables. Let's take a closer look on these:

### Assembler
This module compiles specified by source into a binary file. Also it generates compilation listing that consists information about line, opcode and instruction pointer of the instruction and file header.

### Disassembler
Decompiles binary file into a disassembly file with binary header, instructions pointers of commands and commands themself

### Processor
Provides functionality for executing and debugging precompiled binaries

## Installation

### Dependencies
To compile this repository you have [sfml 2.6](https://www.sfml-dev.org/index.php "sfml") or higher and [GNU readline](https://tiswww.case.edu/php/chet/readline/rltop.html "GNU readline") to be installed on your computer. [Cmake](https://cmake.org/) is used for building project, so you need to install it as well. Current version of a program works only on GNU/Linux (tested on arch and ubuntu).

### Downloading
To download emulator simply clone it's [GitHub repository](https://github.com/Iprime111/Processor) and `cd` to Processor folder:
```bash
$ git clone https://github.com/Iprime111/Processor.git
$ cd Processor
```
Then, to download static libraries run:
```bash
$ git submodule update --init --remote --recursive
```

### Building
Cmake in this project currently doesn't have Release/Debug building options, so to build it, run cmake from the build directory:
``` bash
$ mkdir build
$ cmake ..
$ cmake --build .
```
All the binaries will be saved into the `build/bin` folder.

## Usage

There are some examples of modules usage (assuming you're in build folder). Flags order does not matter for all of the modules.

> Warning: Only one source, listing, binary or output can be specified for each module. Specifying more than one can lead to the undefined behaviour

### Assembler

To compile file with source code you have to specify it's location using `-s` or `--source` flag. If output binary path is not set by `-o` or `--output`, compiler will generate `a.out` file in your current folder. Listing will not be generated, unless you use `-l` or `--listing` flag to set it's location. Here's most common example of using assembler:
``` bash
$ ./bin/Assembler -s /path/to/source -o /path/to/binary -l /path/to/listing
```

You can also write debug information into a binary file by using `-d` or `--debug` compilation flag

> Warning: writing debug info can make file size extremly big

Debug mode assembly example:

``` bash
$ ./bin/Assembler -s /path/to/source -o /path/to/binary -l /path/to/listing --debug
```

### Disassembler

 Disassembler needs binary file to be specified with `-b` or `--binary` flag. Also you can set output disassembly file with `-o` or `--output`. Default output file name is `a.disasm`.

 Usage example:

 ``` bash
$ ./bin/Disassembler -b /path/to/binary -o /path/to/output
 ```

### Processor

This program has a bit more console flags than previous ones. List of them, their functions and accepted values is presented below:

| short flag name | long flag name | flag function                                        | accepted value                                      |
|-----------------|----------------|------------------------------------------------------|-----------------------------------------------------|
| `-b`            | `--binary`     | sets a binary file for executing                     | path to a binary file                               |
| `-s`            | `--source`     | sets a source file (needed for debugging)            | path to a source file                               |
| `-f`            | `--frequency`  | sets processor frequency (ram latency simulation)    | integer number betweent 1 and 4200 (defaul: 4200)   |
| `-d`            | `--debug`      | runs program in debug mode                           | no arguments                                        |
| `-g`            | `--graphics`   | enables sfml graphics (GPU emulation)                | no arguments                                        |

Usage example:

``` bash
$ ./bin/SoftProcessor -b /path/to/binary -s /path/to/source -f 4200 --debug --graphics
```

## Processor usage details

There are some small details in processor usage that you have to take into account:

### Debug mode

To correctly debug compiled binary file you have to use `--debug` when assembling and running program. If no debug info has been found in binary file but `--debug` flag has been set when running processor, it will launch disassembler to decompile binary and let you debug it's decompiled version. Auto-generated disassembly will be situated by the `./binaryname_disassembly_autogenerated.tmp` path.

> Warning: in current version processor is trying to find disassembler in the same folder (assuming they're stored together). Undefined behaviour can occure if processor is launched from another folder

### Graphics mode

Processor uses sfml launched in main thread to display image from virtual `VRAM`. Each three `VRAM` adresses corresponds to a one pixel's colors. (`VRAM` adresses are `0~29999`).

## Assembler syntax

### Basic syntax
Every not blank line (except line with only comments in it) consists of a command and it's arguments. If there're two arguments specified, they should be splitted by a plus sign `+` (without whitespace) and register argument should come first. Line may have a comment that starts from `;` symbol. Every line should have one or zero instructions on it. Every program execution should end with `hlt` command for correct behaviour. Example:

```
; This program reads value, multiplies by 5 and prints it

push 5  ; push 5 to a stack
in      ; read value from stdio
mul     ; multiply read value by 5
out     ; print result

hlt     ; Stop processor
```

### Instructions
There are 23 processor instructions in current assembler version. Each one is showed in the table below:

| Instruction | Accepted arguments                      | Description                                                                     |
|-------------|-----------------------------------------|---------------------------------------------------------------------------------|
| push        | Number, register, memory address        | Pushes value to the processor stack                                             |
| pop         | Register, memory address                | Pops value from the processor stack                                             |
| hlt         | No arguments                            | Stops program and turns the processor off                                       |
| in          | No arguments                            | Reads numeric value from stdio stream (accepts all double values)               |
| out         | No arguments                            | Prints value to stdout stream                                                   |
| add         | No arguments                            | Adds two values from the top of the stack                                       |
| sub         | No arguments                            | Subtracts first value in the stack from the second                              |
| mul         | No arguments                            | Multiplies two values from the top of the stack                                 |
| div         | No arguments                            | Divides second value in the stack on the first                                  |
| floor       | No arguments                            | Converts stack top value to an integer by removing fraction part                |
| sin         | No arguments                            | Takes sin of the last value in the stack                                        |
| cos         | No arguments                            | Takes cos of the last value in the stack                                        |
| sqrt        | Bytecode address                        | Takes square root of the last value in the stack                                |
| jmp         | Bytecode address                        | Jumps to the specified address                                                  |
| ja          | Bytecode address                        | Jumps if the second value in the stack is greater than the first                |
| jae         | Bytecode address                        | Jumps if the second value in the stack is greater than the first or equal to it |
| jb          | Bytecode address                        | Jumps if the second value in the stack is less than the first                   |
| jbe         | Bytecode address                        | Jumps if the second value in the stack is less than the first or equal to it    |
| je          | Bytecode address                        | Jumps if two top values in the stack are equal                                  |
| jne         | Bytecode address                        | Jumps if two top values in the stack are not equal                              |
| call        | Bytecode address                        | Pushes return address to the call stack and jumps to the spcified address       |
| ret         | Bytecode address                        | Pops return address from call stack and jumps to it                             |
| sleep       | Number, register, memory address        | Pauses processor thread for a specified count of microseconds                   |

### Registers
There are 8 available registers from rax to rhx. Each one contains numeric value that can be used in program. Example

```
; This program reads value, squares and prints it

in          ; read value
pop rax     ; store value into a rax register

push rax
push rax    ; push rax value to the stack twice
mul         ; square value
out         ; print result

hlt         ; Stop processor
```

### Two arguments
Two arguments can be passed to some instructions by using plus sign without whitespaces beetwen them. Their values will be added and passed to a command. Example:

```
; This program adds 5 to a given number, and prints the result

in          ; Read value

pop rax     ; Store value in stack
push rax+5  ; Push rax value + 5 to the stack

out         ; Print value
hlt         ; Stop program
```

### Memory address address and ram structure
Processor memory is splitted into two different sections: `RAM` and `VRAM`. As it've been said before, `VRAM` addresses are `0~29999` and `RAM` addresses are `30000~30099`. All data from `VRAM` will be displayed on the screen, while ram data are only accessable from your code. Every memory address is a double number cell.
Memory addresses can be accessed from code by using square brackets (`[]`) to specify address either by number or by register value. Example:

``` asm
push [56]   ; pushes value from a memory cell with address 56
push [rax]  ; pushes value from a memory cell with address taken from rax value
```

> Warning: value is automaticly floored if it's used as a memory address

> Warning: undefined behaviour can occure if you're trying to get access to an out of range addresses

### Labels
Label can be defined (once) by writing any single word (english characters and numbers without whitespaces) with trailing `:` symbol. Every label name that has been found in your code will be changed to a label address. Example:

```
ip  | code
----|--------------------------------------------------
37  | Begin:          ; defines label with address 37
37  |     push 5
.   |     ...
132 |     jmp Begin   : jumps to address 37
```

> Warning: every label can be defined only once
> Warning: if label is not defined, but it's value is used in code, it will be counted as value -1


