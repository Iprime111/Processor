//INSTRUCTION(NAME, COMMAND_CODE, PROCESSOR_CALLBACK, ASSEMBLER_CALLBACK)

#define COMMA ,

INSTRUCTION (hlt, {0 COMMA 0}, {
    RETURN PROCESSOR_HALT;
}, {})

INSTRUCTION (out, {1 COMMA 0}, {
    elem_t value {};
    PopValue(spu, &value);

    printf_color (CONSOLE_WHITE, CONSOLE_BOLD,
    "╔═══════════════════════════════╗\n"
    "║ Output data:                  ║\n"
    "╚═══════════════════════════════╝\n"
    "\033[15C \033[2A"
    ); //Escape codes for positioning cursor

    PrintData (CONSOLE_DEFAULT, CONSOLE_BOLD, stdout, value);
    printf ("\033[1B\r");

    fputs ("\n", stdout);
}, {})

INSTRUCTION (in, {2 COMMA 0}, {
    elem_t value {};

    printf_color (CONSOLE_WHITE, CONSOLE_BOLD,
    "╔═══════════════════════════════╗\n"
    "║ Enter value:                  ║\n"
    "╚═══════════════════════════════╝\n"
    "\033[14C \033[2A"
    ); //Escape codes for positioning cursor

    scanf ("%lf", &value);
    printf ("\033[1B\r");

    PushValue (spu, value);

}, {})

INSTRUCTION (push, {3 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT}, {
    elem_t value = 0;
    unsigned char registerIndex = REGISTER_COUNT;

    if (commandCode->arguments == (IMMED_ARGUMENT | REGISTER_ARGUMENT)){
        ReadData (spu, &registerIndex, char);
        ReadData (spu, &value,         elem_t);

        value += spu->registerValues [registerIndex];

    }else if (commandCode->arguments & REGISTER_ARGUMENT){
        ReadData (spu, &registerIndex, char);

        value = spu->registerValues [registerIndex];
    }else if (commandCode->arguments & IMMED_ARGUMENT) {
        ReadData (spu, &value, elem_t);
    }else {
        RETURN WRONG_INSTRUCTION;
    }

    PushValue (spu, value);
}, {})

INSTRUCTION (pop, {4 COMMA REGISTER_ARGUMENT}, {
    if (commandCode->arguments & REGISTER_ARGUMENT){
        unsigned char registerIndex = REGISTER_COUNT;
        ReadData (spu, &registerIndex, char);

        PopValue (spu, spu->registerValues + registerIndex);
    } else {
        RETURN WRONG_INSTRUCTION;
    }
}, {})

INSTRUCTION (add, {5 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value1 + value2);
}, {})

INSTRUCTION (sub, {6 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value2 - value1);
}, {})

INSTRUCTION (mul, {7 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value1 * value2);
}, {})

INSTRUCTION (div, {8 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value2 / value1);
}, {})

INSTRUCTION (sin, {9 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, sin (value));
}, {})

INSTRUCTION (cos, {10 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, cos (value));
}, {})

INSTRUCTION (sqrt, {11 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, sqrt (value));
}, {})

INSTRUCTION (jmp, {12 COMMA IMMED_ARGUMENT}, {
    unsigned long long jmpAddress = 0;
    ReadData (spu, &jmpAddress, unsigned long long);


    Jump (spu, jmpAddress);
}, {JumpAssemblerCallback})

#undef COMMA
