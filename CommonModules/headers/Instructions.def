//INSTRUCTION(NAME, COMMAND_CODE, PROCESSOR_CALLBACK, ASSEMBLER_CALLBACK, DISASSEMBLER_CALLBACK)

#define COMMA ,

INSTRUCTION (hlt, {0 COMMA 0}, {
    RETURN PROCESSOR_HALT;
}, {}, {})

INSTRUCTION (out, {1 COMMA 0}, {
    elem_t value {};
    PopValue(spu, &value);

    printf_color (CONSOLE_WHITE, CONSOLE_BOLD,
    "╔═══════════════════════════════╗\n"
    "║ Output data:                  ║\n"
    "╚═══════════════════════════════╝\n"
    "\033[15C \033[2A"
    ); //Escape codes for positioning cursor

    PrintData (CONSOLE_DEFAULT, CONSOLE_BOLD, stdout, value);
    printf ("\033[1B\r");

    fputs ("\n", stdout);
}, {}, {})

INSTRUCTION (in, {2 COMMA 0}, {
    elem_t value {};

    printf_color (CONSOLE_WHITE, CONSOLE_BOLD,
    "╔═══════════════════════════════╗\n"
    "║ Enter value:                  ║\n"
    "╚═══════════════════════════════╝\n"
    "\033[14C \033[2A"
    ); //Escape codes for positioning cursor

    scanf ("%lf", &value);
    printf ("\033[1B\r");

    PushValue (spu, value);

}, {}, {})

INSTRUCTION (push, {3 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    PushValue (spu, *argument);
}, {}, {})

INSTRUCTION (pop, {4 COMMA REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    PopValue (spu, argument);
}, {}, {})

INSTRUCTION (add, {5 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value1 + value2);
}, {}, {})

INSTRUCTION (sub, {6 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value2 - value1);
}, {}, {})

INSTRUCTION (mul, {7 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value1 * value2);
}, {}, {})

INSTRUCTION (div, {8 COMMA 0}, {
    elem_t value1 {};
    elem_t value2 {};

    PopValue (spu, &value1);
    PopValue (spu, &value2);

    PushValue (spu, value2 / value1);
}, {}, {})

INSTRUCTION (sin, {9 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, sin (value));
}, {}, {})

INSTRUCTION (cos, {10 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, cos (value));
}, {}, {})

INSTRUCTION (sqrt, {11 COMMA 0}, {
    elem_t value {};

    PopValue (spu, &value);

    PushValue (spu, sqrt (value));
}, {}, {})

INSTRUCTION (jmp, {12 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    Jump (spu);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (ja, {13 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, GREATER);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (jae, {14 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, GREATER | EQUAL);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (jb, {15 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, LESS);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (jbe, {16 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, LESS | EQUAL);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (je, {17 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, EQUAL);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})

INSTRUCTION (jne, {18 COMMA IMMED_ARGUMENT | REGISTER_ARGUMENT | MEMORY_ARGUMENT}, {
    ConditionalJump (spu, LESS | GREATER);
}, {JumpAssemblerCallback}, {JumpDisassemblerCallback})


#undef COMMA
